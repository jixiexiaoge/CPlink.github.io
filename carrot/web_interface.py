#!/usr/bin/env python3
"""
Webç•Œé¢æ¨¡å— - ä¿®å¤å®Œæ•´ç‰ˆ
è´Ÿè´£HTTPæœåŠ¡å™¨å’ŒWebç•Œé¢å¤„ç†
"""

import json
import os
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs

class WebInterface:
    """Webç•Œé¢å¤„ç†å™¨"""
    
    def __init__(self, controller):
        self.controller = controller
        self.web_server = None

    def create_web_handler(self):
        """åˆ›å»ºWebå¤„ç†å™¨"""
        controller = self.controller

        class OvertakeHTTPHandler(BaseHTTPRequestHandler):
            def do_GET(self):
                """å¤„ç†GETè¯·æ±‚"""
                if self.path == '/':
                    self.send_html_response()
                elif self.path == '/status':
                    self.send_json_status()
                else:
                    print(f"page {self.path} not found!")

            def do_POST(self):
                """å¤„ç†POSTè¯·æ±‚"""
                try:
                    content_length = int(self.headers.get('Content-Length', 0))
                    post_data = self.rfile.read(content_length).decode('utf-8')
                    data = json.loads(post_data) if post_data else {}

                    if self.path == '/control':
                        self.handle_control(data)
                    elif self.path == '/overtake':
                        self.handle_overtake(data)
                    elif self.path == '/config':
                        self.handle_config(data)
                    elif self.path == '/params':
                        self.handle_params(data)
                    else:
                        self.send_error(404, "æ¥å£æœªæ‰¾åˆ°")
                except Exception as e:
                    print(f"è¯·æ±‚å¤„ç†é”™è¯¯: {e}")
                    self.send_error(400, "è¯·æ±‚è§£æé”™è¯¯")

            def handle_control(self, data):
                """å¤„ç†æ§åˆ¶å‘½ä»¤"""
                cmd_type = data.get('type', '')
                value = data.get('value', '')
                if cmd_type == 'SPEED':
                    controller.change_speed(value)
                self.send_json_response({'status': 'success', 'command': f'{cmd_type}: {value}'})

            def handle_overtake(self, data):
                """å¤„ç†è¶…è½¦å‘½ä»¤ - ä¿®å¤çŠ¶æ€æ˜¾ç¤º"""
                if 'manual' in data:
                    # ä¿®å¤ï¼šæ‰‹åŠ¨æ“ä½œæ—¶çŸ­æš‚æ˜¾ç¤ºçŠ¶æ€
                    controller.control_state['overtakeState'] = f"å‡†å¤‡æ‰‹åŠ¨{data['manual']}å˜é“"
                    controller.control_state['overtakeReason'] = "æ‰§è¡Œç”¨æˆ·æ‰‹åŠ¨å˜é“æŒ‡ä»¤"
                    controller.manual_overtake(data['manual'])
                    self.send_json_response({'status': 'success', 'action': f'manual_{data["manual"]}'})
                elif 'cancel' in data:
                    controller.control_state['overtakeState'] = "å–æ¶ˆè¶…è½¦"
                    controller.control_state['overtakeReason'] = "ç”¨æˆ·å–æ¶ˆè¶…è½¦æ“ä½œ"
                    controller.cancel_overtake()
                    self.send_json_response({'status': 'success', 'action': 'cancel'})
                elif 'auto' in data:
                    new_auto = bool(data['auto'])
                    old_auto = controller.config['autoOvertakeEnabled']
                    controller.config['autoOvertakeEnabled'] = new_auto
                    controller.save_persistent_config()
                    
                    # æ–°å¢ï¼šè‡ªåŠ¨è¶…è½¦å¼€å…³çŠ¶æ€çŸ­æš‚æ˜¾ç¤º
                    status_text = "å·²å¯ç”¨" if new_auto else "å·²å…³é—­"
                    controller.control_state['overtakeState'] = f"è‡ªåŠ¨è¶…è½¦{status_text}"
                    controller.control_state['overtakeReason'] = f"ç”¨æˆ·{'å¼€å¯' if new_auto else 'å…³é—­'}è‡ªåŠ¨è¶…è½¦"
                    
                    self.send_json_response({'status': 'success', 'autoOvertake': controller.config['autoOvertakeEnabled']})
                elif 'autol' in data:
                    new_autol = bool(data['autol'])
                    controller.config['autoOvertakeEnabledL'] = new_autol
                    controller.save_persistent_config()
                    
                    # æ–°å¢ï¼šæ™®é€šé“è·¯è‡ªåŠ¨è¶…è½¦å¼€å…³çŠ¶æ€çŸ­æš‚æ˜¾ç¤º
                    status_text = "å·²å¯ç”¨" if new_autol else "å·²å…³é—­"
                    controller.control_state['overtakeState'] = f"æ™®é€šé“è·¯è‡ªåŠ¨è¶…è½¦{status_text}"
                    controller.control_state['overtakeReason'] = f"ç”¨æˆ·{'å¼€å¯' if new_autol else 'å…³é—­'}æ™®é€šé“è·¯è‡ªåŠ¨è¶…è½¦"
                    
                    self.send_json_response({'status': 'success', 'autoOvertakeL': controller.config['autoOvertakeEnabledL']})
                elif 'return' in data:
                    new_return = bool(data['return'])
                    old_return = controller.config['shouldReturnToLane']
                    controller.config['shouldReturnToLane'] = new_return
                    controller.save_persistent_config()

                    # å¦‚æœå…³é—­è¿”å›åŠŸèƒ½ï¼Œé‡ç½®ç›¸å…³çŠ¶æ€
                    if not new_return and old_return:
                        controller.reset_net_lane_changes()
                        print("ğŸ”„ ç”¨æˆ·å…³é—­è¿”å›åŠŸèƒ½ï¼Œé‡ç½®å‡€å˜é“æ¬¡æ•°")
                    
                    # çŠ¶æ€è‡ªç„¶æ¢å¤ä¸º"ç­‰å¾…è¶…è½¦æ¡ä»¶"
                    self.send_json_response({'status': 'success', 'returnToLane': controller.config['shouldReturnToLane']})
                else:
                    self.send_json_response({'status': 'error', 'message': 'æœªçŸ¥æ“ä½œ'})

            def handle_config(self, data):
                """å¤„ç†é…ç½®æ›´æ–°"""
                if 'lane_count_mode' in data:
                    mode = data['lane_count_mode']
                    if mode in ['manual', 'auto', 'op']:
                        controller.config['lane_count_mode'] = mode
                        controller.calculate_lane_count()
                        controller.save_persistent_config()

                if 'lanes' in data and controller.config['lane_count_mode'] == 'manual':
                    lanes = int(data['lanes'])
                    if 1 <= lanes <= 5:
                        controller.config['lane_count'] = lanes
                        controller.config['manual_lane_count'] = lanes
                        controller.save_persistent_config()

                if 'manual_lane_count' in data and controller.config['lane_count_mode'] == 'manual':
                    lanes = int(data['manual_lane_count'])
                    if 1 <= lanes <= 5:
                        controller.config['manual_lane_count'] = lanes
                        controller.config['lane_count'] = lanes
                        controller.save_persistent_config()

                if 'road_type' in data:
                    new_road_type = data['road_type']
                    old_road_type = controller.config['road_type']

                    controller.config['road_type'] = new_road_type

                    if old_road_type == 'highway' and new_road_type == 'normal':
                        controller.reset_net_lane_changes()
                        print("ğŸ›£ï¸ åˆ‡æ¢åˆ°æ™®é€šé“è·¯ï¼Œé‡ç½®è¿”å›çŠ¶æ€")

                    controller.calculate_lane_count()
                    controller.save_persistent_config()

                self.send_json_response({'status': 'success', 'config': controller.config})

            def handle_params(self, data):
                """å¤„ç†å‚æ•°æ›´æ–° - ä¿®æ­£å•ä½æ¢ç®—"""
                param_map = {
                    'highwayMinSpeed': 'HIGHWAY_MIN_SPEED',
                    'normalMinSpeed': 'NORMAL_ROAD_MIN_SPEED',
                    'speedRatio': 'CRUISE_SPEED_RATIO_THRESHOLD',
                    'followTimeGap': 'FOLLOW_TIME_GAP_THRESHOLD',
                    'maxFollowTime': 'MAX_FOLLOW_TIME',  # ğŸ¯ å…³é”®ä¿®å¤ï¼šæœ€å¤§è·Ÿè½¦æ—¶é—´
                    'minLaneWidth': 'MIN_LANE_WIDTH',
                    'safeLaneWidth': 'SAFE_LANE_WIDTH',
                    'sideLeadDist': 'SIDE_LEAD_DISTANCE_MIN',
                    'sideRelSpeed': 'SIDE_RELATIVE_SPEED_THRESHOLD',
                    'leadRelSpeed': 'LEAD_RELATIVE_SPEED_THRESHOLD',
                    # ğŸ†• v3.7 æ–°å¢å‚æ•°
                    'highwayLeadMinSpeed': 'HIGHWAY_LEAD_MIN_SPEED',
                    'normalLeadMinSpeed': 'NORMAL_LEAD_MIN_SPEED',
                    'earlyOvertakeSpeedRatio': 'EARLY_OVERTAKE_SPEED_RATIO',
                    'earlyOvertakeMinLeadSpeed': 'EARLY_OVERTAKE_MIN_LEAD_SPEED',
                    'earlyOvertakeMinDistance': 'EARLY_OVERTAKE_MIN_DISTANCE',
                    'earlyOvertakeMaxDistance': 'EARLY_OVERTAKE_MAX_DISTANCE',
                    'earlyOvertakeMinSpeedDiff': 'EARLY_OVERTAKE_MIN_SPEED_DIFF'
                }

                for web_key, config_key in param_map.items():
                    if web_key in data:
                        if web_key == 'maxFollowTime':
                            # ä¿®å¤ï¼šå°†åˆ†é’Ÿè½¬æ¢ä¸ºæ¯«ç§’
                            minutes = float(data[web_key])
                            controller.config[config_key] = int(minutes * 60 * 1000)  # åˆ†é’Ÿ â†’ æ¯«ç§’
                            print(f"â° æœ€å¤§è·Ÿè½¦æ—¶é—´è®¾ç½®: {minutes}åˆ†é’Ÿ â†’ {controller.config[config_key]}æ¯«ç§’")
                        elif web_key == 'speedRatio' or web_key == 'earlyOvertakeSpeedRatio':
                            controller.config[config_key] = float(data[web_key]) / 100.0
                        else:
                            controller.config[config_key] = float(data[web_key])

                controller.save_persistent_config()
                self.send_json_response({'status': 'success', 'message': 'å‚æ•°å·²ä¿å­˜'})

            def send_html_response(self):
                """å‘é€HTMLé¡µé¢"""
                html = self.get_html_content()
                self.send_response(200)
                self.send_header('Content-type', 'text/html; charset=utf-8')
                self.end_headers()
                self.wfile.write(html.encode('utf-8'))

            def send_json_status(self):
                """å‘é€JSONçŠ¶æ€æ•°æ®"""
                status_data = controller.get_status_data()
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps(status_data, ensure_ascii=False).encode('utf-8'))

            def send_json_response(self, data):
                """å‘é€JSONå“åº”"""
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps(data, ensure_ascii=False).encode('utf-8'))

            def get_html_content(self):
                """è·å–HTMLæ–‡ä»¶å†…å®¹"""
                html_file_path = os.path.join(os.path.dirname(__file__), 'web_interface.html')
                try:
                    with open(html_file_path, 'r', encoding='utf-8') as f:
                        return f.read()
                except FileNotFoundError:
                    return "<html><body><h1>é”™è¯¯ï¼šæœªæ‰¾åˆ°HTMLç•Œé¢æ–‡ä»¶</h1></body></html>"

            def log_message(self, format, *args):
                """ç¦ç”¨è®¿é—®æ—¥å¿—"""
                pass

        return OvertakeHTTPHandler

    def start_web_server(self):
        """å¯åŠ¨WebæœåŠ¡å™¨"""
        handler = self.create_web_handler()
        self.web_server = HTTPServer(('0.0.0.0', 8088), handler)
        print("ğŸŒ WebæœåŠ¡å™¨å¯åŠ¨åœ¨ç«¯å£ 8088")
        self.web_server.serve_forever()